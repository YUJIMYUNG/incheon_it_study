package ex5_casting;

class Parent{};
class Child extends Parent{};




public class Ex1_class_casting {
	public static void main(String[] args) {
		Parent p1 = new Parent();
		Child c1 = new Child();
		
		
		Parent p2 = new Child();// 자동타입변환
		Parent p3 = c1;//이미 만들어진 자식객체를 부모p3 변수에 넣는다. 자동타입변
		//Child c2 = p1; 자동 타입 변환 불가능.. 
		
		//기본 자료형끼리 비교할 때 == 연산자는 값이 같은지 비교하지만
		//객체끼리 비교할 때는 주소값이 같은지 비교한다. 
		if(p3 == c1) {
			System.out.println("p3 / c1 주소값이 같습니다.");
		}else {
			System.out.println("p3 / c1 주소값이 같지 않습니다.");
		}
		
		//타입을 변환한다고 객체가 바뀌는것은 아니고, 객체는 보존되고 사용을 부모객체처럼 한다.
		//자동타입변환은 반드시 자식클래스의 객체를 부모 타입으로 변환할 때 적용할 수 있다.
		//1차 상속 관계가 아니더라도 상위 계층의 타입으로 변환할 수 있다. 
		//하지만 같은 상위 계층을 갖고 있더라도 타입변환을 시도하려는 두 클래스의 상속관계가 없다면
		//타입 변환은 불가능하다.
		
		
		//자식 객체의 메서드가 호출되는 이유
		// 메서드가 실행 시점에서 성격이 결정되는 동적바인딩 때문이다.
		//프로그램의 컴파일 시점에 부모 클래스는 자신의 멤버함수밖에 접근할 수 없다.
		//실행 시점에 동적바인딩이 일어나 부모가 자식 클래스의 멤버함수에 접근하여 실행할 수 있다.
		
		
		//정적바인딩
		//변수 및 함수가 컴파일 시점에 바인딩되는 것
		
		//동적바인딩
		//실행시점(메서드가 호출될 때) 결정
		//작동 방법
		//1. 클래스 계층구조
		//자바에서 동적바인딩은 클래스 계층 구조에서 발생한다.
		//상속하거나 인터페이스를 구현함으로써 계층을 갖는다.
		//이 계층에서 메서드 오버라이딩이 가능하기 때문이다.
		
		//2, 메서드 오버라이딩
		//자식 클래스는 부모 클래스의 메서드를 오버라이딩 할 수 있다.
		//이 때, 자식 클래스에서 부모 클래스의 동일한 이름과 시그니처(매개변수의 개수, 타입)를 가진 메서드를 재정의한다.
		
		//3. 실행시 동적바인딩
		//객체가 생성되고 메서드가 호출될 때, 실제로 실행될 메서드는 객체의 실제 타입에 따라 결정된다.
		//메서드 호출시 객체의 클래스 타입을 기반으로 어떤 메서드를 호출할지 동적으로 결정된다.
		
		
		
		
		
	}
}
